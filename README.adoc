= Cray System Management - Package & Repository Manifest
:toc:
:toclevels: 2

This repository serves as a manifest for CSM's https://github.com/Cray-HPE/[node-images] repository.

Each deliverable is built for multiple mediums, this repository groups manifests by deliverable and their
expected mediums.

== Usage

. Set your username and API key from https://artifactory.algol60.net into your environment.
+
[source,bash]
----
export ARTIFACTORY_UER=
export ARTIFACTORY_TOKEN=
----
. Check for package updates (the example below looks at `base.packages` for `node-image-ncn-common`).
+
[source,bash]
----
./scripts/update-package-versions.sh -a x86_64 -p packages/node-image-ncn-common/base.packages
----
. Or, validate manifests (verify what's listed can be resolved from our Artifactory instance).
+
[source,bash]
----
./scripts/update-package-versions.sh -a aarch64 -p packages/node-image-compute/base.packages --validate
----

It is worthwhile to note that when checking out a new git-branch, where repositories may or may not have changed, running `--refresh`
or purging the docker image may aid updating and validating the manifests.

* Refresh an existing image.
+
[source,bash]
----
./scripts/update-package-versions.sh -a x86_64 --refresh
----
* Purge the updater image and delete any dependent containers, an alternative to using `--refresh` for a fresh start
+
[source,bash]
----
docker rmi -f csm-rpms-cache
----

== Content

This list denotes the various content deliverables we build at CSM. Each items in this list has its own list of packages:

- `packages/node-images-base`
+
Packages for every image that directly inherits from a base image (e.g. application, compute, ncn-common). 
- `packages/node-image-ncn-common`
+
https://github.com/Cray-HPE/node-images/tree/main/boxes/ncn-common[Build Repo]
+
Packages specific to every NCN image (e.g. Kubernetes, pre-install-toolkit, or Storage-CEPH)
- `packages/node-image-kubernetes`
+
https://github.com/Cray-HPE/node-images/tree/main/boxes/ncn-node-images/kubernetes[Build Repo]
+
Packages specific to the Kubernetes image.
- `packages/node-image-pre-install-toolkit`
+
https://github.com/Cray-HPE/node-images/tree/main/boxes/ncn-node-images/pre-install-toolkit[Build Repo]
+
Packages specific to the pre-install-toolkit (a.k.a. LiveCD)
+
- `packages/node-image-storage-ceph`
+
https://github.com/Cray-HPE/node-images/tree/main/boxes/ncn-node-images/storage-ceph[Build Repo]
+
Packages specific to the Storage-CEPH image.
+
- `packages/node-image-compute`
+
https://github.com/Cray-HPE/node-images/tree/main/boxes/compute[Build Repo]
+
Packages specific to the compute image.

== Mediums

Each content deliverable builds a Google and a Metal artifact:
- Google: An artifact delivered to GCP for use in vShasta
- Metal: An artifact delivered into Artifactory for use on real hardware

.There could be more types of artifacts as time goes on, for now we only build deliverables for Google and Metal.

Each `.package` file in each of the content deliverable folders listed in <<Content>> divide packages up by
medium (e.g. Google or Metal).

- `base.packages` are common to any build
- `google.packages` are only installed into Google builds
- `metal.packages` are only installed into Metal builds

== Adding Packages

When adding a package, by default any/all packages should go into the `base.packages` `base-<<ARCH>>.packages` file. This helps keep our artifacts common between each delivery endpoint (preventing divergence from Google and Metal).
If the package is specific to a medium or architecture, it should go into one of the other `.package` files.

=== Examples

For example, `nginx` is necessary in Google to server some data to the vShasta deployment from Kubernetes nodes. However, CSM does not want `nginx` installed on metal since it serves
no purpose for metal installs and would only add an extra unnecessary service. Therefore `nginx` is only installed in Google artifacts of `node-image-kubernetes`.

Another example, `dracut-metal-mdsquash` handles partitioning disks to serve to a booted Live squashFS image. It
is a necessity for Metal artifacts, specifically the Non-Compute Nodes.
However, vShasta handles disks entirely differently, and having this package would complicate vshasta
boots. Therefore, `dracut-metal-mdsquash` is installed in the `node-image-ncn-common` layer so any NCN derivative will have this package, and it is
specifically listed in the `metal.packages` file.

An example of a double-inclusion, `keepalived` and `haproxy` are both needed in Kubernetes and Storage-CEPH images and are explicitly listed in both instead of being listed in node-image-ncn-common.
This is because if another NCN type were to be created, or if any other node were to import the common layer, that node may not want these two packages. It could be argued that these should exist
in ncn-common anyway, but for the sake of not over-specializing the ncn-common layer these remain excluded.

A final example, `cray-site-init` is used for initializing a system in any context. This package is needed in the pre-install toolkit, that is available during an installation before non-compute nodes are deployed.
This package is used for both Metal and vShasta (Google), albeit it might not always be used by developers of vShasta the package itself is usable in either context. Therefore `cray-site-init` is
installed into the `node-image-pre-install-toolkit` via the `base.packages` file, making it available on both Metal and vShasta PITs.

